## 搜索螺旋排序数组（中等）

> **题目：**
>
> 假设按照升序排序的数组在预先未知的某个点上进行了旋转。
>
> ( 例如，数组 `[0,1,2,4,5,6,7]` 可能变为 `[4,5,6,7,0,1,2]` )。
>
> 搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 `-1` 。
>
> 你可以假设数组中不存在重复的元素。
>
> 你的算法时间复杂度必须是 *O*(log *n*) 级别。
>
> **示例 1:**
>
> ```
> 输入: nums = [4,5,6,7,0,1,2], target = 0
> 输出: 4
> ```
>
> **示例 2:**
>
> ```
> 输入: nums = [4,5,6,7,0,1,2], target = 3
> 输出: -1
> ```

## 解答：

#### 分析：

​	用==二分法==的思想。一半一定是有序的，另一半不确定。以有序的一半为重点，仍旧利用二分法搜索的思想，找到目标值。

​	需要解决的**难点**：1. 循环条件的设置；2. 有序判断条件的设置。

​	思路：

 	1. 序列左端下标 l <= 右端下标 r 时，满足循环条件。设置等号是因为会出现只剩下一个数字需要进行判断的情况。
 	2. 如果n[l] <= n[c] 说明该段序列是有序的，因为如果无序，例如：4,5,6,7,0,1  n[l]是一定比n[c]大的。此处有等号是因为：c 可能和 l 取同一值，比如 2,3  l=0,r=1 ==> c = 0，这样的情况也是按有序处理的。
 	3. 针对有序序列，如果目标值在有序序列范围内，就用二分法进行查找，否则进入另一序列查找。
 	4. 针对不确定序列，先判断目标值是否在另一段有序序列里，如果在用二分法查找；若不在，则继续划分不确定序列（此处划分的意思就是：也是利用二分法的思想在该不确定序列一点点缩小范围，直到分到有序序列）

**注：**==二分法查找要求序列是有序序列是因为，需要用中间值和目标值作比较，确定是在中间值前面的序列找还是在后面的序列找。==然后分析中说不确定序列里也用二分法思想，此时的二分法思想就是将序列一分为二的意思，从而能逐渐划分出有序序列，然后执行二分查找。

#### 实现：

```java
class Solution {
    public int search(int[] nums, int target) {
        int l = 0, r = nums.length - 1;
        int res = -1;
        while(l <= r){ //必须有等号，因为只剩下一个数需要检测时，l=r
            int c = (l + r) / 2; //中间值
            if(nums[c] == target){
                return c;
            }
            if(nums[l] <= nums[c]){ //有序 (l = c的情况也属于有序)
                if(nums[c] > target && nums[l] <= target){ //在有序序列内
                    r = c - 1;
                }else{
                    l = c + 1;
                }
            }else{ //无序
                if(nums[r] >= target && nums[c] < target){ //在有序序列内
                    l = c + 1;
                }else{
                    r = c - 1;
                }
            }           
        }
        
        return res;
    }
}
```

LeetCode上运行：执行用时2ms，内存消耗34.5MB。时间复杂度logn 。