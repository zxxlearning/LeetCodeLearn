## 盛最多水的容器（中等）

> **题目：**
>
> 给定 *n* 个非负整数 *a*1，*a*2，...，*a*n，每个数代表坐标中的一个点 (*i*, *ai*) 。在坐标内画 *n* 条垂直线，垂直线 *i* 的两个端点分别为 (*i*, *ai*) 和 (*i*, 0)。找出其中的两条线，使得它们与 *x* 轴共同构成的容器可以容纳最多的水。
>
> **说明：**你不能倾斜容器，且 *n* 的值至少为 2。
>
> ![img](pics/question_11.jpg)
>
> 图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。
>
> **示例：**
>
> ```java
> 输入: [1,8,6,2,5,4,8,3,7]
> 输出: 49
> ```

## 解答：

#### 分析：

​	利用==动态规划==的思想，容器面积 = 小的值 * 两个值的距离。

​	**不可行的解题分析**：

​	如果从左往右找最大的容器面积，采用**累加**的解题思路，下一块小面积区域更大时，一定可以重新新起一块面积；但是如果下一块小面积区域小于等于[当前的加上下一块小面积组成的新面积区域]时，就不一定是选择：重起一块，还是把下一块加到之前的上面。这里比较麻烦，不太可行！！

​	**可行的解题分析**：

​	依旧是动态规划的思想，但是是从两端开始往内缩小区域，从而在这个过程中寻找最大的容积。

​	用指针l指向当前容器最左边的值，指针r指向当前容器最右边的值。

​	当前容器的面积 = 两指针的距离 *  左右端中小的那个值。

​	每进行一步向内移动的操作时，有两种操作：左 ++ 或 右 - -。**==难点==就是何时l ++，何时r - -**。

​	因为每次计算面积时，用到的都是左右两个值中，小的那个值。

​	（1）每次向内移动的是指向大值的指针，结果有两种情况：<1>距离变小了，但是值仍比没做移动的小值大 ==> 新面积减小 <2>距离变小了，但是值比没做移动的小值还小 ==> 新面积减小。此时面积一定是减小的！

​	（2）每次向内移动的是指向小值的指针，结果得到的面积可能变大，可能变小。就可以在这个过程中比较当前存储的最大容器面积和本次计算得到的容器面积，从而得到最大的容器面积。

#### 实现：

```java
class Solution {
    public int maxArea(int[] height) {
        int l = 0;
        int r = height.length - 1;
        int res = 0;
        while(l < r){ 
            int area = Math.min(height[l], height[r]) * (r - l); //当前的面积
            //当前面积和之前存储的最大面积作比较，把最大值赋给最终结果
            res = Math.max(res, area); 
            if(height[l] < height[r]){
                l ++;
            }else{
                r --;
            }
        }        
        return res;
        
    }
}
```

LeetCode上运行：执行用时6ms，内存消耗43.4MB。时间复杂度n 。