## 不同路径（中等）

> **题目：**
>
> 一个机器人位于一个 *m x n* 网格的左上角 （起始点在下图中标记为“Start” ）。
>
> 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。
>
> 问总共有多少条不同的路径？
>
> ![img](pics/robot_maze.png)
>
> 例如，上图是一个7 x 3 的网格。有多少可能的路径？
>
> **说明：** m 和 n 的值均不超过 100。
>
> **示例 1：**
>
> ```
> 输入: m = 3, n = 2
> 输出: 3
> 解释:
> 从左上角开始，总共有 3 条路径可以到达右下角。
> 1. 向右 -> 向右 -> 向下
> 2. 向右 -> 向下 -> 向右
> 3. 向下 -> 向右 -> 向右
> ```
>
> **示例 2：**
>
> ```
> 输入: m = 7, n = 3
> 输出: 28
> ```

## 解答1：

#### 分析：

​	机器人只能向右或向下移动，所以一共可以移动（m + n - 2）步，而且一定是向右移动（m - 1）步，向下移动（n - 1）步。所以就是求
$$
C_{m+n-2}^{m-1}或者C_{m+n-2}^{n-1}
$$

#### 实现：

```java
class Solution {
    public int uniquePaths(int m, int n) {
        if(m < 0 || n < 0){
            return 0;
        }
        int k = Math.min((m - 1), (n - 1)); //向右或向下的步数中小的那个数
        int sum = m + n - 2; //一共需要走的步数
        long c1 = 1, c2 = 1;
        while(k > 0){
            c1 *= sum;
            c2 *= k;  
            sum --;
            k --;
        }
        return (int)(c1/c2);
    }
}
```

LeetCode上运行：执行用时1ms，内存消耗32.7MB。时间复杂度m或n 。

## 解答2：

#### 分析：

​	用一个二维数组 dp[ n ] [ m ] 存放从左上角（起始点）到位置（i,j）时一共可能的路径数。因为只能向右或向下运动，当i = 0或j = 0时，只能向右或向下移动，因此只有一条路径。其他情况下，每次到达（i,j）位置时，一定会先经过该位置的左面或上面，所以此处（i,j）的路径数就等于（i-1,j）+（i,j-1）的路径数。

#### 实现：

```java
class Solution {
    public int uniquePaths(int m, int n) {
        if(m < 1 || n < 1){
            return 0;
        }
        //虽然看网上答案是int[m][n],但我看题目,我觉得应该m是列，n是行
        int[][] dp = new int[n][m];
        //机器人只能向下或向右移动
        for(int i = 0; i < n; i ++){
            for(int j = 0; j < m; j ++){
                dp[i][j] = (0 == i*j) ? 1 : (dp[i - 1][j] + dp[i][j - 1]);
            }
        }
        return dp[n-1][m-1];
    }
}
```

LeetCode上运行：执行用时1ms，内存消耗32.5MB。时间复杂度m * n 。